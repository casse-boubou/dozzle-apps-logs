##################################
# authelia.log
##################################
<source>
  @type tail
  path /logs/authelia.log
  pos_file /var/log/fluentd/authelia.pos
  tag authelia
  refresh_interval 5s
  read_from_head true
  read_lines_limit 1000
  
  <parse>
    @type regexp
    # pattern: time="2020-01-01T00:00:00+11:00" level=info msg="Logging severity set to info"
    expression /time=\"(?<time>[^\"]*)\" level=(?<level>\S+) msg=\"(?<msg>[^\"]*)\"(?: header=(?<header>\S+))?(?: method=(?<method>\S+))?(?: path=(?<path>\S+))?(?: remote_ip=(?<remote_ip>\S+))?(?: username=(?<username>\S+))?(?: scheme=(?<scheme>.*))?/
    time_key time
    timezone +01:00
    time_format %Y-%m-%dT%H:%M:%S%:z
  </parse>
</source>

# Reconstruire le message pour authelia
<filter authelia>
  @type record_transformer
  enable_ruby true
  renew_record true # afin de creer un record avec seulement les champs entrer dans <record>
  <record>
    timestamp ${time.strftime('%Y-%m-%dT%H:%M:%S.%6N%:z')}
    container ${tag}
    message ${"level=#{record['level']} msg=\"#{record['msg']}\" " + ['header', 'method', 'path', 'remote_ip', 'username', 'scheme'].select{|k| record[k] && !record[k].to_s.empty?}.map{|k| "#{k}=#{record[k]}"}.join(' ')}
  </record>
</filter>


##################################
# swag.log
##################################
<source>
  @type tail
  path /logs/swag.log
  pos_file /var/log/fluentd/swag.pos
  tag swag
  refresh_interval 5s
  read_from_head true
  read_lines_limit 1000
  
  <parse>
    @type regexp
    # pattern: '$remote_addr - $remote_user [$time_local] "$request_method $scheme://$host$request_uri $server_protocol" $status $body_bytes_sent "$http_referer" "$http_user_agent" $request_length $request_time [$upstream_app] [$upstream_addr]'
    expression /(?<remote_addr>\S+) - (?<remote_user>\S+) \[(?<time>[^\]]*)\] \"(?<request_method>\S+) (?<scheme>[^:]*):\/\/(?<host>[^\/]*)(?<request_uri>\S+) (?<server_protocol>(HTTP\/)\d.\d|-)\" (?<status>\d{3}) (?<body_bytes_sent>\d+) \"(?<http_referer>[^\"]*)\" \"(?<http_user_agent>[^\"]*)\" (?<request_length>\d+) (?<request_time>[0-9.]+) \[(?<upstream_app>[^\]]*)\] \[(?<upstream_addr>[^g-zG-Z]*)\]$/
    time_key time
    timezone +0100
    time_format %d/%b/%Y:%H:%M:%S %z
  </parse>
</source>

# Reconstruire le message pour swag
<filter swag>
  @type record_transformer
  enable_ruby true
  renew_record true # afin de creer un record avec seulement les champs entrer dans <record>
  <record>
    timestamp ${time.strftime('%Y-%m-%dT%H:%M:%S.%6N%:z')}
    container ${tag}
    message ${"remote_addr=\"#{record['remote_addr']}\" application=\"#{record['upstream_app']}\" method=\"#{record['request_method']}\" request=\"#{record['scheme']}://#{record['host']}#{record['request_uri']}\" protocol=\"#{record['server_protocol']}\" status=\"#{record['status']}\" body_bytes_sent=\"#{record['body_bytes_sent']}\" http_user_agent=\"#{record['http_user_agent']}\" request_length=\"#{record['request_length']}\" request_time=\"#{record['request_time']}\""}
  </record>
</filter>


##################################
# supprime le warning au demarragfe de fluentd
##################################
<label @FLUENT_LOG>
  <match fluent.**>
    @type null
  </match>
</label>


##################################
# Sortie: un fichier .log parser par log
##################################
<match **>
  @type file
  path /logs-parsed/${tag}.json
  append true
  add_path_suffix false
  
  <format>
    @type json
  </format>
  
  <buffer tag>
    @type file
    path /var/log/fluentd/buffer
    flush_mode immediate
    retry_type exponential_backoff
  </buffer>
</match>